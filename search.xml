<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EnglisReading-2]]></title>
    <url>%2F2019%2F03%2F09%2FEnglisReading-2%2F</url>
    <content type="text"><![CDATA[Young children should be taught in their mother tongue, not in English 12tongue:舌头 语言 mother tongue :母语 English perfectly exemplifies the “network effects” of a global tongue: the more people use it, the more useful it is. Over a billion people speak it as either their first or second language; more still as a third or fourth language.12345678exemplifies:作为、、典型the more people use it, the more useful it is. the more 、、、 the more、、、 Over a billion people speak it as either their first or second language as 作为 Parents’ desire for their children to master English is spurring the growth of private schooling. Education authorities are switching to English medium, in part to stem the outflow of children into the private sector.12345678910111213141516171819202122232425master English :master v.精通 --&gt;精通英语spur： n. 鼓舞，刺激；马刺；山坡 vi. 骑马疾驰；给予刺激 vt. 激励，鞭策；给…装踢马刺 n. (Spur)人名；(意)斯普尔；(德)施普尔 spur into action eg：i was spur into action by her speech Education authoritie 教育部门 medium/ˈmiːdiəm/ n. （传播或表达的）媒体，方法；教学媒介语言 e.g. 相关词汇：media (n.) 搭配短语：medium of instruction 例句：English is still the main medium of instruction in Nigeriain part 在一定程度stem ：阻止 to stem the tide of immigrationsector ：部门 这里只学校 Teaching children in English is fine if that is what they speak at home and their parents are fluent in it. But that is not the case in most public and low-cost private schools. Children are taught in a language they don’t understand by teachers whose English is poor. The children learn neither English nor anything else. Research demonstrates that children learn more when they are taught in their mother tongue than they do when they are taught in any other language. In a study of children in the first three years in 12 schools in Cameroon, those taught in Kom did better than those taught in English in all subjects.1demonstrates :证实，证明 English should be an important subject at school, but not necessarily the language of instruction. Rather than switching to English-medium teaching, governments fearful of losing custom to the private sector should look at the many possible ways of improving public schools.123456789101112131415161718language of instruction 教学语言 e.g. instruction 英文释义： the act of teaching sth. to sb. 例句：In Malaysia, the primary language of instruction is English.fearful of :惧怕custom/ˈkʌstəm/ n. （经常性的）顾客，客源 e.g. 相关词汇：customer (n.) 例句：Thank you for your custom.look at 思考，考虑 e.g. 英文释义：to think about, consider or study something]]></content>
      <categories>
        <category>English Reading Comprehension</category>
      </categories>
      <tags>
        <tag>EnglishReading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全域划分]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%AE%89%E5%85%A8%E5%9F%9F%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[安全域 0x01安全体系都离不开一些必要的基本的安全措施，基本安全措施是后期纵深防御体系建立的必要基础。安全域：指同一系统内有相同的安全保护需求，相互信任，并具有相同的安全访问控制和边界控制策略的子网或网络，且相同的网络安全域共享一样的安全策略。广义可理解为具有相同业务要求和安全要求的IT系统要素的集合。目前比较流行的安全域划分方式为：根据业务划分、根据安全级别划分传统安全域划分：其实传统的安全域划分原则就是把企业网络划分成两部分，外部网络（DMZ区域）和内部网络（企业网络），中间使用防火墙建立边界. 0x02生产网 纵向上划分数据中心（敏感业务，设置严格的安全策略）业务服务（底层服务、中间件、前端服务、……），规模再大一些的企业，可以把各个业务服务也细分 横向上划分根据不同的安全等级、业务需求进行横向划分。但是横向划分可能会给业务间的相互调用造成困难。这个需要达到业务需求与安全需求的平衡，安全需要根据业务的情况给出更多方案选择，如网关安全加固（在网络边界上做防御） 办公服务区 可能会有内部信息泄漏风险的服务器（邮件、人力资源、财务系统） 涉及代码资产的服务器（代码托管、……） 开发测试区 其他办公服务…… 办公区 事业部A敏感岗位（根据策略差异可以适当调整）高管HR、行政财务法务 重度PC用户 普通研发(这里是指不需要登录生产网服务器的研发) 需要生产网服务器操作的人员：DBA、运维、研发（根据策略差异也可以将这三类人员划入不同的安全域） 中度PC用户 重要业务系统管理员 普通运营 轻度PC用户 客服、线下销售、…… 外包…… 外网 生产网络和办公网络划分：生产网络和办公网络划分主要是为了防御域渗透 生产网络的SSH端口在前端防火墙和交换机上默认不允许访问 远程访问需要通过VPN或者专线才能连接到生产网络 通过生产网络的网段要做好隔离，阻止来自于外网服务器的连接可以访问OA、HR等与内部运营相关的系统 办公网中的运维系统、发布源和其他的系统在L2层次上隔离 运维网段和办公网段接入的链路互相独立 运维专线要采取ISP热备份，防止ISP故障导致无法访问 堡垒机和跳板机要有全流量审计 系统安全加固： 禁用LKM：LKM是Linux内核为了扩展其功能所使用的可加载内核模块。LKM的优点：动态加载，无须重新实现整个内核。基于此特性，LKM常被用作特殊设备的驱动程序（或文件系统），如声卡的驱动程序等等。关闭LKM好处是可以规避一些LKM的Rootkit，关闭LKM的命令如下： root@elknot# echo 1 &gt; /proc/sys/kernel/modules_disabled（sysctl -w kernel.modules_disable=1），但是这样做一旦重启计算机就会失效，所以我们要使用永久的方法来关闭LKM：首先先使用make config或者make menuconfig，在Loadable Module Support选项中的Enable Loadable Module Support（CONFIG_MODULES）选择N 限制/dev/mem：/dev/mem可以通过mmap可以将物理地址映射到用户空间的虚拟地址上，在用户空间完成对设备寄存器的操作。如果紧紧关闭LKM的话，依然可以通过读取/dev/mem或者/dev/kmem来在用户模式下实现内核rootkit，比如suckit。新版的系统中默认不使用/dev/kmem这个文件，我们需要查看/boot下的config文件来确定CONFIG_DEVKMEM设置为N并且CONFIG_STRICT_DEVMEM设置为Y。 开启ASLR：首先我们要开启全局ASLR，ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。据研究表明ASLR可以有效的降低缓冲区溢出攻击的成功率，如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。开启ASLR的方法如下： 1234root@zm# echo 2&gt;/proc/sys/kernel/randomize_va_space0：关闭ASLR。1：mmap base、stack、vsdo page将随机化，也就是说.so文件将被加载到随机地址，并且连接时制定了-pie选项的可执行程序，代码加载地址也会随机化。配置内核时候如果指定了CONFIG_COMPAT_BRK，该值会默认为1。但是这个时候heap没有随机化。2：heap随机化，如果配置内核的时候禁用了CONFIG_COMPAT_BRK，该值为 bash zsh history添加命令时间 并且只能设置追加： 1chattr +a ~/.bash_history //设置追加模式 应用配置加固： 目录权限：有句话说得好——可读目录不可写，可写目录不可读，这句话恰好说的就是用来对抗webshell攻击，大意为攻击者通过文件上传漏洞上传webshell或者通过应用层漏洞在目录下写入了一个webshell，因为没有执行权限无法通过webshell执行命令，或者当目录有解析执行权限的时候因为没有写权限无法生成webshell文件达到阻止渗透的目的。但是发展到现在来看，以后这个规则越用越小也说不定。可读目录不可写翻译成命令就是： 1.chmod 755 webroot如果部分子目录因为业务原因需要高权限的话，请更改目录拥有者为web进程：2.chown webserver: webroot。 可写目录不可读在nginx的php配置就是：localtion ~ ^data/cgisvr/log/..(php|php5) ${deny all;}，如果要是Java的话，因为tomcat默认解析jspx格式文件，如果不需要的话可以去修改conf下面的web.xml注释掉 *.jspx 。 Web进程以非root权限运行：web进程以非root权限运行遵循最小权限原则，如果以root运行，则会导致exp攻击时直接拿到root权限或者当应用层代码出现问题时会直接以root权限执行webshell命令。检测方法是使用ps -ef来查看master进程和worker进程，master进程默认以root运行，而worker默认以nobody权限运行。 远程访问：这里注意的比较少，只需要把ssh版本设置成v2（修改ssh的配置文件中Protocol为2）并且仅用root远程登录（PermitRootLogin为No）即可 账号密码：这里很容易出现一个比较头疼的问题就是暴力破解，鉴于账号的特殊性，密码爆破成为了最常用的手段。对待暴力破解的方法通常是引入双因子认证，但是如果开启了账户登录失败锁定策略的话，很容易就把暴力破解演变成为DoS攻击，所以针对安全团队而言，平时应该去收集一些比较新的密码爆破数据库，同时也要周期性更新这个密码库，但凡出现在这个密码库里的密码，不管有多强的复杂度，都应该认定成为弱密码 网络ACL：其实这里的话，系统级的NACL无论是粒度还是其他方面，用默认自带的iptables基本就够用了，只开放服务端口和管理端口，对于数据库而言只开放应用服务器的IP才能连接 补丁集管理：安全团队需要考虑的是评估漏洞的危害和对自身的影响，这点依赖于很多的事情，比如资产和配置的管理、系统层和应用层的漏洞判定，甚至还有实际的攻击面和利用可能性等。从安全团队的角度出发，我们的补丁集管理应该做到大批量的打补丁并且尽量不去影响正常业务，同时要具备一定的容灾能力，同时提供hotfix热补丁，并且要同时针对单个漏洞进行快速扫描。 日志审计：这里需要分析的就是一些系统级日志，比如lastlog，syslog，sshlog，weblog等，可以接入ELK、Splunk这些数据分析平台123456789101112131415161718系统日志： /var/log/boot.log：录了系统在引导过程中发生的事件，就是Linux系统开机自检过程显示的信息 /var/log/lastlog ：记录最后一次用户成功登陆的时间、登陆IP等信息 /var/log/messages ：记录Linux操作系统常见的系统和服务错误信息 /var/log/secure ：Linux系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况 /var/log/btmp ：记录Linux登陆失败的用户、时间以及远程IP地址 /var/log/syslog：只记录警告信息，常常是系统出问题的信息，使用lastlog查看 /var/log/wtmp：该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件，使用last命令查看 /var/run/utmp：该日志文件记录有关当前登录的每个用户的信息。如 who、w、users、finger等就需要访问这个文件连接时间日志： /var/log/wtmp /var/run/utmp 注：这里的日志不能直接用cat命令查看，可以通过w/who/finger/id/last/lastlog/ac进行查看web服务器日志： /var/log/nginx：Nginx日志默认位置 $TOMCAT_HOME\logs：Tomcat日志位置 /usr/local/apache/logs/access_log：Apache日志位置 /usr/local/apache2/logs：Apache2日志位置 附录参考文章：elknot企业安全建设日记—- 企业安全建设之安全域划分]]></content>
      <categories>
        <category>安全运维</category>
      </categories>
      <tags>
        <tag>安全域</tag>
        <tag>企业安全建设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EnglisReading-1]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%B5%81%E5%88%A9%E9%98%85%E8%AF%BB-1%2F</url>
    <content type="text"><![CDATA[Vaccine could virtually eliminate cervical cancer：study vaccine：疫苗 eg：vaccine against tetaus（破伤风）vaccination 接种 cervical：宫颈的 – cervix 子宫颈 eg：cervial cancer virtually ：实质上，实际上 eg：he was virtually a prisoner be virtually forgotten（几乎被遗忘） The rapid scale-up of the human papillomavirus (HPV) vaccine could virtually eliminate cervical cancer in a handful of rich countries within three decades, and in most other nations by century’s end, researchers said Wednesday. scale-up 扩大 scale v.扩大 增大eg：the scale-up of 5G technology papillomavirus 乳头瘤 a handful of :少量的 minorty 少量的，少数 Without screening and HPV vaccination, more than 44 million women will likely be diagnosed with the disease over the next 50 years, they reported in The Lancet Oncology, a medical journal. screening ：检察，筛选 screen n.屏幕，屏风 v.放映 拍摄 diagnose:诊断 be diagnose with sthhe has recently been diagnosedwith diabetes By contrast, the rapid deployment starting in 2020 of screening and vaccination could prevent more than 13 million cervical cancers by mid-century worldwide, and lower the number of cases to below four-per-100, 000 women, the study found. by contrast 与之相比，相反 in contrast 相比之下 deployment n.部署 应用 v. deploy 部署the deployment of AI technology mid-century 中业 “This is a potential threshold for considering cervical cancer to be eliminated as a major public health problem, “ the authors said in a statement. threshold 门界，门槛，界限 on the threshold of sththey are on the threshold of adulthood “Despite the enormity of the problem, our findings suggest that global elimination is within reach, “ said lead author Karen Canfell, a professor at the Cancer Council New South Wales, in Sydney. enormity 严重性 巨大的 enormous 巨大的 庞大的 within reach 近在咫尺 near by Achieving that goal, however, depends on “both high coverage of HPV vaccination and cervical screening, “ she added. coverage :范围 规模 Clinical trials have shown that HPV vaccines are safe and effective against the two HPV strains—types 16 and 18—responsible for 70 percent of cervical cancer cases. Clinical adj .临床的 clininc 诊所 trials n.试验 审判（trial） strains 变种 变体 The study’s projections presume the vaccination of 80 percent of girls 12 to 15 years old starting in 2020, and that at least 70 percent of women undergo screening twice in their lifetime. projections 预测 presume 假设 This would push the prevalence of the disease below the bar of 4/100, 000 women in countries such as the United States, Canada, Britain and France by 2059, and in mid-income countries such as Brazil and China by 2069, the authors calculate. prevalence ：流行 普及]]></content>
      <categories>
        <category>English Reading Comprehension</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找工作笔记]]></title>
    <url>%2F2019%2F03%2F08%2F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[0x01 tips： 最近在找工作，由于去年参加考研。一心放在考研上，工作没找。后来考研成绩出来了，自己成绩不理想，只能乖乖的找工作。自己找的的安全岗位，可是春招的时候安全岗太伤了，就打算往运维方面转。就在边找工作边学习运维的知识，做了一些笔记。 linux基础篇基础的知识在安全的时候学过了这里就不多记载了。就记下自己没遇到的，运维必备的知识。 inux高效文本、文件处理命令vim基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode） 命令模式: i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令 输入模式在命令模式下按下i就进入了输入模式 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。q 退出程序w 保存文件 常用的命令（自己不熟悉，但很常用的命令） G:–&gt;移动到这个档案的最后一行(常用) :shift + gnG : —&gt;移动到这个档案的第 n 行gg :移动到这个档案的第一行/word 光标下搜索word单词所在行？word 光标上搜索 :n1,n2s /word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！ :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) grepsedawkfindshell脚本入门]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试笔记]]></title>
    <url>%2F2019%2F03%2F04%2F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[面试问题 说说web安全有哪些漏洞SQL注入XSS开源框架上传漏洞未授权访问逻辑漏洞（水平权限和垂直权限）弱密码CSRFSSRF 什么是sql注入，怎么防御防御预编译、使用存储过程、检查数据类型、使用安全函数 办公网安全体系建设与研究 我的项目是办公网安全体系建设，因为毕设，我们老师没有要求很大，只要我做出双因子认证在办公网实施就行应付毕设，让我自己思考办公网安全体系建设和树立安全的大局观，而不是针对某个方向。就从我在实习的时候，负责一家公司的渗透测试，当开始做这家公司的时候，黑河测试。从这家公司信息收集开始，发现这家公司对外暴露的业务，都过多过少有安全防御，能地域大量攻击，随着时间和空间维度拉伸，发现该公司并没有明确的边界划分与隔离，公司内部开发系统，内部管理，公司wiki采用另一个域名，通过信息再收集，从而内部大量系统直接暴露给攻击者，内部系统ip端口开放也很随意，从而公司的受攻击面也大量提高。之后给他们公司提出了建议，做出内网隔离，做好内网隔离是企业安全的基础。通过对公司的资产分析，明确我们要保护的目标，通过对安全域的划分，确定安全边界，划分内网和外网，把公司只能内部人访问的如：OA系统，业务后台，服务器控制收入到范围受限，严格管控的内网，严格控制办公网对生产网络的访问，使员工访问设置双因子身份认证。所有服务器非业务端口全部对互联网关闭，管理端口只能通过内部堡垒机访问，必须要对互联网开启的端口要严格做好IP（或者帐号）白名单访问控制。但是仅仅依靠单存的边界防护，一旦某个防护不当便会导致全盘崩溃——所谓“千里之堤毁于蚁穴”是也，认为做好了隔离而忽略了内网的防御，就很容易出现一旦有机器在公网暴露就会被轻松攻破。在资源有限的情况下优先做内网隔离，但是纵深防御也是十分必要的。白帽子讲web安全说过，纵深防御在不同的层面、不同方面实施安全方案实施一个整体的解决方案，这时需要考虑到主机安全，web应用安全，终端系统安全，数据库安全等等。像腾讯安全应急中心说过的河防体系，把对手控制在一个可控的范围内，防御的要义是控，步步为营，层层设防，就算入侵，也在计算的可控范围内。这个河方体系，需要公司有一定安全团队和对抗能力，其次360提出的 塔防体系。塔防体系优于纵深防御的是，强调了终端要纳入安全防御网络中，并具有自我防御能力，并且要实现云端的管控能力和威胁情报数据。而对于下一代纵深防御体系，我现在还没有去了解和学习。一个企业的安全体系建设，要依靠自己公司的业务规模，安全需求考虑。一个刚发展的公司，不可能需要像美国五角大楼那种安全防护，一般的公司，现有公司最好的资源最大化利用率就是最好网络隔离和纵深防御。但公司的防护不能依靠单的的pretect（防护）来防护，需要动态防护过程。 安全是一个持续的过程，没有绝对的安全。攻击和防御是不断对抗，不断发展的。应对不断新的攻击，安全模型从最初的PDR，到P2DR，再到MP2DR动态防御模型，现在很多互联网安全需求要求更高的企业，都对这些雏形演化出对于新的模型。pretecttion，检测dection（不断地检测和监控网络系统，来发现新的威胁和弱点，通过循环反馈来及时做出有效的响应。当攻击者穿透防护系统时，检测功能就发挥作用，与防护系统形成互补）和响应response（实时性应急响应和入侵后应急响应）安全模型：PDR（protection、Dection、response 强调了PDR中的Detection的重要性） P2DR模型（Policy，Protect、Detection、Response） 强调安全策略是安全模型的核心，所有防护、检测、响应都是依靠安全策略实施的。其中包括总体安全策略和具体安全策略。缺点：系统本身安全免疫能力的增强、系统和整个网络的优化以及人员这个系统中最重要的素质提升，都是该安全模型没有考虑到的问题。 PPDR模型（Predict，Prevent、Detection、Response）这种安全模型在不同阶段引入威胁情报、大数据分析等新技术和服务，旨在构建一个能进行持续性威胁响应、智能化、协同化的安全防护体系.核心是威胁预测，过情报主动发现各种移动应用面临的各种攻击，并将情报反馈到防护阶段和检测功能，从而构成整个威胁处理流程的闭环。该模型获业界主流安全企业和研究机构认可在2017年。 MP2DR模型（management，policy、Protect、Detection、Response） 强调安全运营，公司组建 自有的专业安全服务团队，根据公司实际情况研发安全防护产品，实现安全即服务。 P2DRR模型（Policy，Protect、Detection、Response、recovery）eg：（1）策略：定义系统的监控周期、确立系统恢复机制、制定网络访问控制策略和明确系统的总体安全规划和原则。（2）防护：通过修复系统漏洞、正确设计开发和安装系统来预防安全事件的发生；通过定期检查来发现可能存在的系统脆弱性；通过教育等手段，使用户和操作员正确使用系统，防止意外威胁；通过访问控制、监视等手段来防止恶意威胁。采用的防护技术通常包括数据加密、身份认证、访问控制、授权和虚拟专用网（VPN）技术、防火墙、安全扫描和数据备份等。（3）检测：是动态响应和加强防护的依据，通过不断地检测和监控网络系统，来发现新的威胁和弱点，通过循环反馈来及时做出有效的响应。当攻击者穿透防护系统时，检测功能就发挥作用，与防护系统形成互补。（4）响应：系统一旦检测到入侵，响应系统就开始工作，进行事件处理。响应包括紧急响应和恢复处理，恢复处理又包括系统恢复和信息恢复 风险评估风险分析，除了评估造成损失大小，还要评估对事件发生的可能性，危险程度。DREAD模型Damage PotentialReproducibilityExpliotiablityAffect userDiscoverability五个方面去评估 应急响应过程应急响应学习渗透实战，并了解应急响应流程。应急响应流程可分为两类：实时性应急响应和入侵后应急响应；实时性应急响应：大多为DDOS攻击，首要进行流量分析，若流量打满，能做的就是反查攻击IP，逆向渗透；若网络设备会话数被打满或者主机系统的CPU、内存、会话数被打满，可通过交换机做端口镜像，使用wireshark、tcpdump进行抓包，分析流量特征，确认攻击类型，在网络设备或安全设备上做相应阻断策略；攻击后应急响应：通过分析恶意文件和日志，查找入侵来源IP和入侵者所利用的漏洞，提出漏洞修补方案，并逆向追踪入侵者；应急响应对工程师的要求较为复杂，需多熟悉不同操作系统、应用、中间件、数据库特性，且能熟练使用编程语言或者vim等编辑器对较大的日志进行数据整理，还需要日常多多积累各种攻击特征和防护策略； osi7层模型与纵深防御对于网络工程师来说这是一个大问题。纵深防御可以从两个不同的角度来解释这个概念。首先，从分层安全机制的高度来理解，将其称作纵深防御。纵深防御是标准的方法论，它从三个层次强调安全需求：管理、技术和业务。在分层之前，建立纵深防御更注重的是策略和程序，而不是实际保护资源的安全机制。纵深防御包括物理安全和人为安全。正如问题所述，OSI模型是解释纵深防御概念的基础。大家应该都知道纵深防御意味着使用多种途径和多种保护方法实现安全保护。可以通过讨论OSI模型各层所采取的防护来了解纵深防御。作为公司，他会为物理线路聘用一个巡线员（第一层），在交换机上坐端口安全（第二层），在边界路由器上作访问列表（第三层），在防火墙中建立非管制区和包过滤（第四层）设置IDS/IDP监测/阻拦（第三~第七），建立SSL通道（第六层），设置内容过滤（第七层），提供AAA服务（第七层），进行漏洞扫描（第四~第七）和病毒扫描（第七层）等… 有没有了解soap注入基于XML语言开发。一个简单的SOAP消息包含:Envelope: 标识XML文档，具有名称空间和编码详细信息。标题：包含标题信息，如内容类型和字符集等。正文：包含请求和响应信息.故障：错误和状态信息SOAP请求易受SQL注入攻击，提交参数作为变种 sql查询可以泄露敏感信息白名单：虽然列表只允许某些字符通过，但在此列表中添加admin等字符会使应用程序只接收列出的字符。过滤：其中涉及通过删除不需要的字符（例如admin’OR’1 = 1’’）来过滤用户输入 – 将被清理，以便只有admin通过它。 xml注入是什么呢XSS 防御对于用户输入相关的数据出入到html中后，被当成html代码一部分执行，混淆了页面原本的语义，产生了新的语义 存储型XSS数据库中存有的存在XSS攻击的数据，返回给客户端。若数据未经过任何转义。被浏览器渲染。就可能导致XSS攻击 反射型XSS将用户输入的存在XSS攻击的数据，发送给后台，后台并未对数据进行存储，也未经过任何过滤，直接返回给客户端。被浏览器渲染。就可能导致XSS攻击 防御策略从输入到输出都需要过滤、转义 输入:客户端求情参数：包括用户输入，url参数、post参数 在产品形态上，针对不同输入类型，对输入做变量类型限制eg：整形输入的，强制整形输入字符串类型的数据：，需要针对&lt;、&gt;、/、’、”、&amp;五个字符进行实体化转义 输出：客户端对用户的输入做了过滤、转义，攻击者一样可能，通过截包，转发等手段，修改你的请求包体 HtmlEncode：Encode的作用是将输入的一些字符进行转化，使得浏览器在最终输出结果上是一样的，但能够防止注入的JavaScript执行 JavaScriptEncode：JavaScriptEncode的作用可以是将输入数据中除了数字、字母外的所有字符进行十六进制化处理，使得浏览器最终输出结果上是一样的，但能够防止注入的JavaScript执行 CSSEncode：当输入数据变量出现在标签内或其它css的执行环境中时，XSS的注入和防御原理同JavaScript URLEncode：可以采用对输入变量进行URLEncode的方法。URLEncode的作用是将字符转化为%HH的形式 空格 --&gt; %20 &lt; --&gt; %3c &gt; --&gt; %3e 说说ssl协议握手过程说下SSRF漏洞的原理，php中触发原理（php哪些函数会导致此漏洞)一种由攻击者构造形成由服务端发起请求的一个安全漏洞原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制攻击者可以利用 SSRF 实现的攻击主要有 5 种：可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息攻击运行在内网或本地的应用程序（比如溢出）对内网 WEB 应用进行指纹识别，通过访问默认文件实现攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）利用 file 协议读取本地文件等 说下csrf漏洞的原理，防御方案跨站请求伪造，攻击者构造预测的链接发送个受害者，迫使受害者执行未授权的行为。在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证随机性——不可预测一次性——每次请求后要更新，不能共用、复用保密性——敏感操作使用post，防止参数在url中泄露 用python写过什么安全小工具，怎么写的？这里简单描述下行了缓冲区溢出的原理是什么怎么定位木马文件，以及木马上传点应急过程自动化http和https优点1 内容加密：建立一个信息安全通道，确保信息传输安全；2 身份认证：确保网站的真实性；3 数据完整性校验：防止内容被第三方冒充或者篡改 tcp、udp区别TCP的优点： 可靠，稳定TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。 UDP的优点： 快，比TCP稍安全UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……UDP的缺点： 不可靠，不稳定因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。基于上面的优缺点，那么： 线程和进程区别，共享变量是不是安全的。最小权限Linux通常希望进程只拥有足够完成其工作的特权，而不希望赋予更多的特权给它，最小特权”就是收缩进程所享有的特权，以防进程滥用特权 什么是访问控制访问控制是网络安全防范和保护的主要策略主要是保证网络资源不被非法使用和非法访问。问控制模型可分为: 传统的访问控制模型(DAC\MAC\ACL)、基于角色的访问控制(RBAC) 模型、基于任务和工作流的访问控制(TBAC) 模型、基于任务和角色的访问控制(T-RBAC) 模型等 访问控制列表ACL:每一项资源，都配有一个列表，这个列表记录的就是哪些用户可以对这项资源执行CRUD中的那些操作.当系统试图访问这项资源时，会首先检查这个列表中是否有关于当前用户的访问权限，从而确定当前用户可否执行相应的操作 基于角色的访问控制RBAC:RBAC是把用户按角色进行归类，通过用户的角色来确定用户能否针对某项资源进行某项操作,使用户和权限关联起来。使得对用户的授权管理变得非常简单和易于维护。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>安全面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac笔记]]></title>
    <url>%2F2019%2F03%2F04%2Fmac%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.terminal代理翻墙Proxychains4 安装Proxychains1brew install proxychains-ng 配置config： Mac下用Homebrew安装的默认为/usr/local/etc/proxychains.conf 12345678910111213141516$ vim proxychains.confquiet_modedynamic_chainchain_len = 1 #round_robin_chain和random_chain使用proxy_dnsremote_dns_subnet 224tcp_read_time_out 15000tcp_connect_time_out 8000localnet 127.0.0.0/255.0.0.0localnet 10.0.0.0/255.0.0.0localnet 172.16.0.0/255.240.0.0localnet 192.168.0.0/255.255.0.0[ProxyList]socks5 127.0.0.1 1086http 127.0.0.1 1087 效果tips：mac 10.13以上需关闭sip 重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。实用工具（Utilities）-&gt; 终端（Terminal）。输入命令csrutil disable运行。重启进入系统后，终端里输入 csrutil status，结果中如果有 System Integrity Protection status:disabled. 则说明关闭成功 dsa]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo-next主题美化(持续更新)]]></title>
    <url>%2F2019%2F02%2F10%2Fhexo-next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[主页文章添加阴影效果效果图：打开\themes\next\source\css_custom\custom.styl向里面加入：1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 文章结尾效果在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------------- 本文结束 &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt; 感谢您的阅读 -------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 完成后效果： 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件，在以下位置插入这样一段代码：1234567891011121314&lt;script&gt; (function () &#123; if (&apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; alert(&apos;密码错误！&apos;); if (history.length === 1) &#123; location.replace(&quot;https://evenyao.com&quot;); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在要加密的文章上添加password属性，后面则是跟想要设置的密码，类似这样： 文章版权说明在目录 next/layout/_macro/下添加 my-copyright.swig：123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import &quot;my-post-copyright&quot; 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加]]></content>
      <tags>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoeditor强大的hexo博客工具]]></title>
    <url>%2F2019%2F02%2F07%2Fhexoeditor%E5%BC%BA%E5%A4%A7%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[HexoEditor是由zhuzhuyule继承Moeditor进而开发的hexoeditor，支持hexo部署，七牛，腾讯云一键上传图片，对于国内用户非常方便。项目地址:Github HexoEditor使用Hexo _config.yml支持 hexo源中的快速新帖子 快速修改文件名（在Hexo Post Edit中） 快速部署帖子 快速HEXO命令hexo d，hexo g，hexo s，hexo clean支持图片国内网站直接快速上传： 自动将图像更改为Markdown 支持拖动图像 支持粘贴剪贴板图像 支持图像云（一步上传） 支持SM.MS 支持齐牛 腾讯 GitHub额外扩展： TeX数学表达式 UML图 编辑中的代码突出显示 读/写/预览模式 自定义字体/行高/字体大小 自定义主题 代码突出显示主题（由highlight.js提供支持）效果展示!]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口常见漏洞(持续更新)]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%AB%AF%E5%8F%A3%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[端口介绍逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到655351.公认端口：0-1023，他们紧密绑定了一些服务，端口的通讯明确表明了某种服务的协议，许多服务绑定于这些端口，这些端口同样用于许多其它目的；2.注册端口：1024-49151，他们松散的绑定了一些服务；3.动态/私有：49152-65535，不为服务分配这些端口；一些端口常常会被黑客利用，还会被一些木马病毒利用，对计算机系统进行攻击，很多木马工具也有特定的端口。 0x00 在给某公司做渗透测试时，该公司主要依靠阿里云服务器，依靠阿里云顿，很多测试工具进行渗透扫描漏洞时，会被及时封ip。很多时候不得不自己写脚本来测试是否存在漏洞，或者已知版本漏洞是否可以利用。单遇到端口这块时，该公司用的是阿里云服务器，生产网服务器都对应有外部ip，生产网很多项目需要开放大量端口同步。这就造成了一个ip可能开放了将近20-30端口。很多端口服务对应已知漏洞，需要每次自己都要去查，慢慢的就积累下了很多端口对应漏洞。也会在以后的遇到新漏洞，持续更新到本文章. 端口渗透通常我们在进行端口渗透时，通常关注： 端口的banner信息 端口上运行的服务 端口运行服务存在已知的漏洞 端口 服务 存在漏洞 21/22/69 ftp/tftp：文件传输协议 爆破 嗅探溢出；后门 22 ssh：远程连接 爆破OpenSSH28个退格 23 telnet：远程连接 爆破嗅探 25 smtp：邮件服务 邮件伪造 53 DNS：域名系统 DNS区域传输DNS劫持DNS缓存投毒DNS欺骗 67/68 dhcp 劫持,欺骗 110 pop3 爆破 139 samba 爆破未授权访问远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击未授权访问 512/513/514 linux r 直接使用rlogin 873 rsync 未授权访问 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录,注入攻击 1521 oracle 爆破：TNS注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破拒绝服务注入 4848 glassfish 爆破：控制台弱口令 认证绕过 5000 sybase/DB2 爆破注入 5432 postgresql 缓冲区溢出注入攻击爆破：弱口令 5632 pcanywhere 拒绝服务代码执行 5900 vnc 爆破：弱口令认证绕过 6379 redis 未授权访问,爆破：弱口令 7001 weblogic Java反序列化控制台弱口令控制台部署webshell 80/443/8080 web 常见web攻击对应服务器版本漏洞 8069 zabbix 远程命令执行 9090 websphere控制台 爆破：控制台弱口令,java反序列 9200/9300 elasticsearch 远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破未授权访问 上述表格转自【作者: Hurricane Security】Hurricane Security]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写python-nmap多线程扫描器]]></title>
    <url>%2F2019%2F01%2F10%2Fpython-nmap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%AB%E6%8F%8F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[python-nmap相关描述1234python-nmap是一个使用nmap进行端口扫描的python库。它可以很轻易的生成nmap扫描报告，并且可以帮助系统管理员进行自动化扫描任务和生成报告。同时，它也支持nmap脚本输出python。 安装使用pip安装 pip install python-nmap常用的使用方法import nmap # 导入 nmap.py 模块nm = nmap.PortScanner() # 实例化nmap.PortScanner对象nm.scan(‘127.0.0.1’, ‘22-443’) # 扫描127.0.0.1,端口号从22至443nm.command_line() # 获取当前执行扫描的命令行: nmap -oX - -p 22-443 127.0.0.1nm.scaninfo() # 获取nmap扫描信息 {‘tcp’: {‘services’: ‘22-443’, ‘method’: ‘connect’}}nm.all_hosts() # 获取所有已经扫描的主机nm[‘127.0.0.1’].hostname() # 获取一个主机127.0.0.1的主机名，通常为用户记录nm[‘127.0.0.1’].hostnames() # 获取主机127.0.0.1的主机名列表，返回一个字典类型 # [{‘name’:’hostname1’, ‘type’:’PTR’}, {‘name’:’hostname2’, ‘type’:’user’}]nm[‘127.0.0.1’].state() # 获取主机127.0.0.1的状态 (up|down|unknown|skipped)nm[‘127.0.0.1’].all_protocols() # 获取执行的协议 [‘tcp’, ‘udp’] 包含 (ip|tcp|udp|sctp)nm[‘127.0.0.1’][‘tcp’].keys() # 获取tcp协议所有的端口号nm[‘127.0.0.1’].all_tcp() # 获取tcp协议所有的端口号 (按照端口号大小进行排序)nm[‘127.0.0.1’].all_udp() # 获取udp协议所有的端口号 (按照端口号大小进行排序)nm[‘127.0.0.1’].all_sctp() # 获取sctp协议所有的端口号 (按照端口号大小进行排序)nm[‘127.0.0.1’].has_tcp(22) # 主机127.0.0.1是否有关于22端口的任何信息nm[‘127.0.0.1’][‘tcp’][22] # 获取主机127.0.0.1关于22端口的信息nm[‘127.0.0.1’].tcp(22) # 获取主机127.0.0.1关于22端口的信息nm[‘127.0.0.1’][‘tcp’][22][‘state’] # 获取主机22端口的状态 (open) python通过调用本地nmap扫描功能进行扫描，以json格式输出,可以由下看到输出的格式。我们后续就可以提取想要的信息。 123456789101112&#123;&apos;nmap&apos;:&#123;&apos;command_line&apos;: &apos;nmap -oX - -n -Pn -sT -sV -p 22 106.15.94.206&apos;, &apos;scaninfo&apos;: &#123;&apos;tcp&apos;: &#123;&apos;method&apos;: &apos;connect&apos;, &apos;services&apos;: &apos;22&apos;&#125;&#125;,&apos;scanstats&apos;: &#123;&apos;timestr&apos;: &apos;Wed Feb 13 13:20:33 2019&apos;, &apos;elapsed&apos;: &apos;0.62&apos;, &apos;uphosts&apos;: &apos;1&apos;, &apos;downhosts&apos;: &apos;0&apos;, &apos;totalhosts&apos;: &apos;1&apos;&#125;&#125;, &apos;scan&apos;: &#123;&apos;106.15.94.206&apos;:&#123;&apos;hostnames&apos;: [&#123;&apos;name&apos;: &apos;&apos;, &apos;type&apos;: &apos;&apos;&#125;], &apos;addresses&apos;: &#123;&apos;ipv4&apos;: &apos;106.15.94.206&apos;&#125;, &apos;vendor&apos;: &#123;&#125;,&apos;status&apos;: &#123;&apos;state&apos;: &apos;up&apos;, &apos;reason&apos;: &apos;user-set&apos;&#125;, &apos;tcp&apos;: &#123;22: &#123;&apos;state&apos;: &apos;open&apos;, &apos;reason&apos;: &apos;syn-ack&apos;, &apos;name&apos;: &apos;ssh&apos;, &apos;product&apos;: &apos;OpenSSH&apos;, &apos;version&apos;: &apos;7.4&apos;, &apos;extrainfo&apos;: &apos;protocol 2.0&apos;, &apos;conf&apos;: &apos;10&apos;, &apos;cpe&apos;: &apos;cpe:/a:openbsd:openssh:7.4&apos;&#125;&#125;&#125;&#125;&#125; portsscan 打造多线程端口扫描器读取ip列表,返回iplist：1234def read_iplist(inputfile): with open(inputfile,&apos;r&apos;) as ip_list: lists = ip_list.read().splitlines() return lists 设置最大线程数：thread_max_num = threading.Semaphore(thread_no)每个线程对应一个ip123456def start(): iplist = read_iplist(input_file) print(&apos;ip列表中共有ip&#123;&#125;个&apos;.format(len(iplist))) for ip in iplist: t = threading.Thread(target=scan_port, args=(ip, output_file)) t.start() 我们需要输出ip；端口；端口类型；服务；这四个模块，根据上面返回json格式，我们提取相应信息；123456789for i in port_list: if (scaninfos[&apos;scan&apos;][ip][&apos;tcp&apos;][i][&apos;state&apos;] == &apos;open&apos;): port_name = scaninfos[&apos;scan&apos;][ip][&apos;tcp&apos;][i][&apos;name&apos;] version = scaninfos[&apos;scan&apos;][ip][&apos;tcp&apos;][i][&apos;extrainfo&apos;] if scaninfos[&apos;scan&apos;][ip][&apos;tcp&apos;][i][ &apos;extrainfo&apos;] != &apos;&apos; else &apos;unknow version&apos; product = scaninfos[&apos;scan&apos;][ip][&apos;tcp&apos;][i][&apos;product&apos;] port_service = &apos;product: &apos; + product + &apos; version:&apos; + version info = [ip, i, &apos;tcp&apos;, port_name, port_service] write_csv(info, outfile=outfile) 输出结果：本项目已同步到github：https://github.com/teazmh/portscan]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>nmap</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试过程（持续更新）]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[渗透测试]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户密码重置找回 10 种常见姿势]]></title>
    <url>%2F2018%2F05%2F30%2F%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E7%9A%8410%E7%A7%8D%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[用户密码重置找回 10 种常见姿势说明： 用户名密码找回通常存在逻辑漏洞，读者因根据实际情况找出相应的漏洞 本片文章是参考补天白帽众学任意用户密码重置的10种姿势视频总结的笔记。视频链接:http://loudong.360.cn/School/content/id/214 1.验证码不失效2.本地验证绕过3.验证码直接返回4.验证码未绑定用户5.修改接受验证码的手机或邮箱6.跳过验证步骤7.未校验用户字段的值8.修改密码处 id 可替换9.cookie 值的替换10.修改信息时替换字段值]]></content>
      <categories>
        <category>逻辑漏洞</category>
      </categories>
      <tags>
        <tag>逻辑漏洞</tag>
        <tag>修改密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-lab学习笔记less6-7（双重查询）]]></title>
    <url>%2F2018%2F05%2F07%2F%E5%8F%8C%E9%87%8D%E6%B3%A8%E5%85%A5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[双重注入查询:相关函数介绍：对于双重查询，需要先了解count，rand（），floor函数功能以及group by语法用法1.concat函数用法concat（string1，string2，string3）将string1，string2，string3字符串连接起来输出（orcle只允许2个字符串）2.count函数我们可以用 select from information_schema.schemata ,来查询当前数据库信息再根据count函数，我们可以得知当前数据库总数，count函数就是列出当前指定值的数目，count（） freom information_schema.schamata中列出数据库的记录数 3.rand（）函数由下图可以看到，selecr rand（）返回的结果是小于1的随机小数. 4.floor（）函数用法floor向下取整 5.group by 用法 GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组 双重查询原理研究人员发现，使用group by结合rand（）以及count（*）这样聚集函数，在sql查询时会出现错误，这种错误随机产生，这样就产生的双重查询注入，使用floor函数只是为了将查询结果分类。下面我们来结果几个函数用法,看几个简单的组合 SELECT floor(rand()2);我们从里向外看。rand() 返回大于0小于1的小数，乘以2之后就成了小于0小于2了。然后对结果进行取证。就只能是0或1了。也就是这个查询的结果不是1，就是0采用如果 SELECT CONCAT((SELECT database()), FLOOR(RAND()2)); select database()返回用户名，再与floor取整函数取得数字相连，floor（rand（））不是0就是1，所以结果又随机两种，SELECT CONCAT((SELECT database()), FLOOR(RAND()*2))a from user; 如果后面跟一个表名，那么就会返回一个集合，集合大小由表本生条数决定。我的数据库有3个管理员，所以就会返回3条记录。我们选择information_schema.tables表来查询，因为表数据多，产生较多的随机数,然后group by 分组显示出来select concat ((select database())), floor(rand()*2))as a from information_schema.tables group by a;其中concat（）as a 是将查询到的结果取一个别名，然后根据别名分组。 这样mysql0分到一组，mysql1分到一组。就只有两种结果了最后再结合count（*），聚集函数，则会有可能报错，但是注意到报错信息所附带我们需要的信息，而不是正常的报错信息。所以就产生了双重查询12SELECT count(*),CONCAT((SELECT user()), FLOOR(RAND()*2))as a from information_schema.tables group by a;(查询当前用户)SELECT count(*),CONCAT((SELECT version()), FLOOR(RAND()*2))as a from information_schema.tables group by a;（查询数据库版本 深层原理：http://wooyun.jozxing.cc/static/drops/tips-14312.html 大神分享的对于less-6 payload1$ http://127.0.0.1/sqli/Less-6/?id=1&quot; union select count(*),1,concat(0x3a,(select database()),0x3a,floor(rand(0)*2))a from information_schema.tables group by a--+ less-5 payload1$ http://127.0.0.1/sqli/Less-5/?id=1&apos; and 1=( select count(*) from information_schema.tables group by concat(0x3a,(select database()),0x3a,floor(rand(0)*2))) --+]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sqli-lab</tag>
        <tag>双重查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openvas]]></title>
    <url>%2F2018%2F02%2F07%2Fopenvas%2F</url>
    <content type="text"><![CDATA[openvas软件介绍OpenVAS是一款开放式的漏洞评估工具，主要用来检测目标网络或主机的安全性，OpenVAS能够基于C/S(客户端/服务器),B/S(浏览器/服务器)架构进行工作，管理员通过浏览器或者专用客户端程序来下达扫描任务，服务器端负载授权，执行扫描操作并提供扫描结果。 服务器层组件openvas-scanner(扫描器):负责调用各种漏洞检测插件，完成实际的扫描操作。openvas-manager(管理器):负责分配扫描任务，并根据扫描结果生产评估报告。 客户层组件openvas-cli(命令行接口):负责提供从命令行访问OpenVAS服务层程序。greenbone-security-assistant(安装助手):负责提供访问OpenVAS服务层的web接口，便于通过浏览器来执行扫描任务，是使用最简便的客户层组件。openvas安装 实验环境：fedora 27 in virtual box（关闭selinux） 1 更新系统软件 sudo yum update -y 2 安装openvas sudo yum intsall openvas* 3 安装redis数据库 sudo yum install redis* 4 安装sqlite3 sudo yum install sqlite3 5 安装证书生成工具 sudo yum install gnutls-utils 6 编译redis 配置文件 sudo vi /etc/redis.conf取消以下两行注释 12# unixsocket /tmp/redis.sock# unixsocketperm 700 7 运行redis服务 sudo redis-server /etc/redis.conf &amp;(&amp;守护程序，后台运行) 8 解决安装问题检查是否安装成功（openvas-check-setup命令指导安装openvas安装问题） 根据提示进一步操作 sudo openvas-check-setup –v9 按照fix提示，可需要如下命令 下载nvt库sudo greenbone-nvt-sync建立本地scapdata数据库sudo greenbone-scapdata-sync获取证书文件sudo grennbone-certdata-sync创建所需要的目录sudo mkdir -p /var/lib/openvas/openvasmd/gnupg/ (-p表示递归创建目录) 9启动scanner sudo openvassd 10 重建数据库 sudo openvasmd –rebuild 11创建用户admin sudo openvasmd –user=admin –new-password=password(password为自己所设密码) 12 生成证书 sudo openvas-manage-certs -a 13 启动greenbone security assistant sudo gsad –listen=127.0.0.1 –port=9392 14 启动openvas管理器 sudo openvassmd 使用openvas-check-setup -v9 出现it seem like your openvas-9 installation is ok 表示安装成功 登录openvas浏览器在浏览器输入https://127.0.0.1:9392(https不可省略)添加信任 advaced-&gt;add exception-&gt;confirm security exception登录admin 和所设密码进入openvas 补充知识需要对扫描配置做一些更改，为之后端口扫描准备 /var/lib/openvas/plugins/nmap.nasl 对nmap.nasl修改407:if(ver)改成if（svc）,411:log_message最后ver前面添加svc388:后面添加花括号，并且在418对花括号闭合413：svc改为string 最后重启openvass]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>openvass</tag>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html学习笔记（一）]]></title>
    <url>%2F2018%2F02%2F07%2Fhtml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是html：html是一种网页描述语言，html使用标记标签来描述网页，web浏览器作用是读取html文档，并且以网页的形式显示它们，浏览器不会显示html标签，而是使用标签来解释页面的内容html基础知识—-html标题HTML 标题（Heading）是通过&lt; h1&gt; - &lt; h6&gt; 等标签进行定义的123&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;h2&gt;This is a heading&lt;/h2&gt;&lt;h3&gt;This is a heading&lt;/h3&gt; html段落HTML 段落是通过 &lt; p&gt; 标签进行定义的。1&lt;p&gt;This is a paragraph.&lt;/p&gt; html链接HTML 链接是通过 &lt; a&gt; 标签进行定义的。1&lt;a href=&quot;http://www.baidu.com&quot;&gt;This is a link&lt;/a&gt; 注释：在 href 属性中指定链接的地址。 html图像HTML 图像是通过 &lt; img&gt; 标签进行定义的。1&lt;img src=&quot;w3school.jpg&quot; width=&quot;104&quot; height=&quot;142&quot; /&gt; HTML 标签对大小写不敏感：&lt; P&gt; 等同于 &lt; p&gt;许多网站都使用大写的 HTML 标签。 html水平线&lt; hr&gt; 标签在 HTML 页面中创建水平线。hr 元素可用于分隔内容。12&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt; html注释可以将注释插入HTML代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们1&lt;!-- 这是一个注释 --&gt; 可以将注释插入HTML代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 面向对象]]></title>
    <url>%2F2018%2F02%2F07%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[相关描述： 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。局部变量：定义在方法中的变量，只作用于当前实例的类。实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。实例化：创建一个类的实例，类的具体对象。方法：类中定义的函数。对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。tips：接触python半年了，一直就用着python基础的方法写一些简单的脚本，没有实现面向对象。在课堂上老师教过Java面向对象，可是自己上课没有认真去了解，靠着最]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 命令]]></title>
    <url>%2F2018%2F02%2F05%2Flinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux基本命令Linux系统下基本命令（要区分大小写 ）uname 显示版本信息（同win2K的 ver）dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）pwd 查询当前所在的目录位置cd cd ..回到上一层目录，注意cd 与..之间有空格。cd /返回到根目录。cat 文件名 查看文件内容cat &gt;abc.txt 往abc.txt文件中写上内容。more 文件名 以一页一页的方式显示一个文本文件。cp 复制文件mv 移动文件rm 文件名 删除文件，rm -a 目录名删除目录及子目录mkdir 目录名 建立目录rmdir 删除子目录，目录内没有文档。chmod 设定档案或目录的存取权限grep 在档案中查找字符串diff 档案文件比较find 档案搜寻date 现在的日期、时间who 查询目前和你使用同一台机器的人以及Login时间地点w 查询目前上机者的详细资料whoami 查看自己的帐号名称groups 查看某人的Grouppasswd 更改密码history 查看自己下过的命令ps 显示进程状态kill 停止某进程gcc 黑客通常用它来编译C语言写的文件su 权限转换为指定使用者telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。ftp ftp连接上某服务器（同win2K） bash_history 显示系统命令时间123# echo &apos;HISTTIMEFORMAT=&quot;%F %T &quot;&apos; &gt;&gt; ~/.bashrc或# echo &apos;HISTTIMEFORMAT=&quot;%F %T &quot;&apos; &gt;&gt; ~/.bash_profile 在bashrc添加如下命令：123456789101112readonly HISTFILE // 更改历史文件名称:HISTFILE=/var/history/$USER-$UID.logreadonly HISTFILESIZE // 定义了在 .bash_history 中保存命令的记录总数.readonly HISTSIZE //控制历史命令的总数readonly HISTCMDreadonly HISTCONTROL //剔除连续的重复条目HISTCONTROL=ignoredups # 使用HISTCONTROL来消除命令历史中的连续重复条目 HISTCONTROL=erasedups # 使用HISTCONTROL在整个历史中去除重复命令 HISTCONTROL=ignorespace # 使用HISTCONTROL强制history忽略某条特定命令(这里是空格)readonly HISTIGNORE #存储历史命令时忽略特殊命令# readonly linux只读命令#为history添加时间戳export HISTTIMEFORMAT=&apos;%F %T &apos; source ~/.bashrc或source ~/.bash_profile chattr 命令chattr +i test.txt 设置只可读 +i -i 去除可读限制chattr +a test.txt 设置只能追加？（append-only） -a取消chattr -R +i ./test-dir/ 对目录所有文件添加限制相关命令如下： a：让文件或目录仅供附加用途。b：不更新文件或目录的最后存取时间。c：将文件或目录压缩后存放。d：将文件或目录排除在倾倒操作之外。i：不得任意更动文件或目录。s：保密性删除文件或目录。S：即时更新文件或目录。u：预防意外删除。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2F2018%2F02%2F05%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[python简介Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。现在 Python 是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。 1 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 一：python安装 Python: https://www.python.org/ Python库的安装 1.使用pip工具：pip install 2.自定义安装：下载.exe文件，然后执行安装 3.通过.whl文件直接安装：下载.whl文件，并且安装了pip和wheel Python库文件的下载地址 &gt; http://www.lfd.uci.edu/~gohlke/pythonlibs/ pip install 库, 安装库* pip unstall 库名 卸载 pip search 库 搜索库 二：python语法及变量类型Python的变量命名规则： 1) 变量名称只能包含 字母，数字，下划线2) 变量名称只能以字母开头3) 变量名称不能和关键字相同4) 变量名称严格区分大小写5) 变量需要被赋值6) 一般在变量未赋值前不会引用 Python关键字： 1)函数，模块，类：def,import ,as，return,class,lambda，from2)逻辑运算符：is，not，or，and，false，true，none3)控制结构：break，continue，if，elif，else，for，in，while，pass，with4)错误处理：except，try，finally，raise5)其他：print,del,global,with,assert,yield,exec 类型转换 不同数据类型之间的转换：1) str(variable):转换成字符串，成功就转换，不成功就报错2) int(variable):试着将variable转换成整数,成功返回整数，否则返回valueerror3) bool(variable):转换布尔型，成功就转换4) float(variable): 转换成浮点型，成功就转换，不成功就报错 三：python运算符 Python中的运算符：1) 算术运算符：+ - / % //2) 比较(关系)运算符：== ，！=，&gt;&lt;,&gt;,&lt;,&gt;=,&lt;=3) 逻辑运算符：and ,or,ot4) 身份运算符：is,is,not,5) 集合(成员)运算符：in,not in6) 赋值运算符：= ，+= ，-=，=，/=,%=,/,//=7) 位运算符:&amp;,|,^,~,&lt;&lt;,&gt;&gt; 补充知识 1)help() 函数用于查看函数或模块用途的详细说明；help([object])2) dir() 函数用于获取对象的大部分相关属性；dir([object)3) doc(): 文档字符串，又称为DocStrings, 用它可以为我们的模块、类、函数等添加说明性的文字，使程序易读易懂，更重要的是可以通过Python自带的标准方法将这些描述性文字信息输出。 python自带的标准方法就是doc, 前后各两个下划线。 当不是函数、方法、模块等调用doc，而是具体对象调用时，会显示此对象从属的类型的构造函数的文档字符串]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
